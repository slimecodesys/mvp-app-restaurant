<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guia do Desenvolvedor</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
            display: flex;
            min-height: 100vh;
        }
        
        .sidebar {
            width: 250px;
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            position: fixed;
            height: 100%;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
            transform: translateX(0);
            z-index: 1000;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
        }
        
        .sidebar h2 {
            text-align: center;
            margin-bottom: 30px;
            color: #ecf0f1;
        }
        
        .sidebar ul {
            list-style-type: none;
            padding: 0;
        }
        
        .sidebar ul li {
            margin-bottom: 10px;
        }
        
        .sidebar ul li button {
            background: none;
            border: none;
            color: #ecf0f1;
            font-size: 16px;
            width: 100%;
            text-align: left;
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            border-radius: 5px;
        }
        
        .sidebar ul li button:hover, .sidebar ul li button.active {
            background-color: #34495e;
            color: #3498db;
        }
        
        .content {
            flex-grow: 1;
            margin-left: 250px;
            padding: 40px;
            transition: margin-left 0.3s ease-in-out;
        }

        .content.full-width {
            margin-left: 0;
        }
        
        .content section {
            display: none;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        
        .content section.active {
            display: block;
        }
        
        h1, h3 {
            color: #2c3e50;
        }
        
        h4 {
            color: #3498db;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
            margin-top: 25px;
        }
        
        code {
            background-color: #eef;
            padding: 2px 4px;
            border-radius: 4px;
            color: #c0392b;
            font-family: 'Courier New', Courier, monospace;
        }
        
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            line-height: 1.4;
            font-size: 14px;
        }

        pre code {
            background-color: transparent;
            color: #f8f8f2;
            padding: 0;
            font-size: 14px;
        }
        
        ul, ol {
            line-height: 1.6;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: #34495e;
            color: #fff;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .toggle-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: #2c3e50;
            color: #ecf0f1;
            border: none;
            padding: 10px 15px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 1001;
            display: none;
        }

        .collapsible-header {
            cursor: pointer;
            background-color: #ecf0f1;
            padding: 15px;
            border-left: 5px solid #3498db;
            margin-top: 20px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            padding: 0 15px;
            background-color: #f9f9f9;
        }

        .collapsible-content.open {
            max-height: 1000px; /* Grande o suficiente para a maioria dos conteúdos */
            padding: 15px;
        }
        
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }
            .sidebar.visible {
                transform: translateX(0);
            }
            .content {
                margin-left: 0;
                padding: 20px;
            }
            .toggle-btn {
                display: block;
            }
            .content.sidebar-visible {
                margin-left: 250px;
            }
        }
    </style>
</head>
<body>

    <button class="toggle-btn" id="toggle-sidebar">☰</button>

    <div class="sidebar" id="sidebar">
        <h2>Guia Dev</h2>
        <ul>
            <li><button onclick="showContent('git')">Git</button></li>
            <li><button onclick="showContent('java')">Java</button></li>
            <li><button onclick="showContent('spring-boot')">Spring Boot</button></li>
            <li><button onclick="showContent('spring-data-jpa')">Spring Data JPA</button></li>
            <li><button onclick="showContent('camadas')">Estrutura de Camadas</button></li>
        </ul>
    </div>

    <div class="content" id="main-content">
        <section id="git">
            <h1>Git</h1>
            <p>O Git é um sistema de controle de versão distribuído, essencial para o desenvolvimento de software. Ele permite que múltiplos desenvolvedores trabalhem em um projeto simultaneamente sem sobrescrever o trabalho um do outro.</p>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Criar uma Branch a partir de uma (dev)</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>Um fluxo comum para criar uma nova branch a partir de uma branch base, como a <code>dev</code>, é o seguinte:</p>
                    <ol>
                        <li><strong>Vá para a branch base:</strong> Certifique-se de que você está na branch <code>dev</code>.</li>
                        <pre><code>$ git checkout dev</code></pre>
                        <li><strong>Atualize a branch base:</strong> Puxe as últimas alterações do repositório remoto para garantir que sua branch local está sincronizada.</li>
                        <pre><code>$ git pull origin dev</code></pre>
                        <li><strong>Crie e mude para a nova branch:</strong> Use o comando <code>-b</code> para criar e, ao mesmo tempo, mudar para a nova branch.</li>
                        <pre><code>$ git checkout -b &lt;nome-da-branch&gt;</code></pre>
                        <li><strong>Suba a nova branch para o repositório remoto:</strong> Isso permite que outros desenvolvedores possam ver e acessar sua branch.</li>
                        <pre><code>$ git push -u origin &lt;nome-da-branch&gt;</code></pre>
                    </ol>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Fazer merge para a Branch (dev)</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>O merge é o processo de integrar as alterações de uma branch em outra. Para fazer o merge da sua branch de feature de volta para a <code>dev</code>:</p>
                    <ol>
                        <li><strong>Troque para a branch de destino:</strong> Vá para a branch que receberá as alterações.</li>
                        <pre><code>$ git checkout dev</code></pre>
                        <li><strong>Atualize a branch de destino:</strong> Puxe as últimas alterações do repositório remoto.</li>
                        <pre><code>$ git pull origin dev</code></pre>
                        <li><strong>Faça o merge:</strong> Integre as alterações da sua branch de feature.</li>
                        <pre><code>$ git merge &lt;nome-da-branch-feature&gt;</code></pre>
                        <li><strong>Resolva conflitos (se houver):</strong> Se o Git detectar conflitos, você precisará resolvê-los manualmente e depois adicionar os arquivos corrigidos com <code>git add</code>.</li>
                        <li><strong>Suba as alterações para o remoto:</strong> Envie as alterações da branch <code>dev</code> para o repositório remoto.</li>
                        <pre><code>$ git push origin dev</code></pre>
                        <li><strong>Apagar a branch local:</strong> Depois do merge, você pode deletar a branch de feature localmente.</li>
                        <pre><code>$ git branch -d &lt;nome-da-branch-feature&gt;</code></pre>
                        <li><strong>Apagar a branch remotamente:</strong> Deletar a branch do repositório remoto.</li>
                        <pre><code>$ git push origin --delete &lt;nome-da-branch-feature&gt;</code></pre>
                    </ol>
                </div>
            </div>
        </section>

        <section id="java">
            <h1>Java</h1>
            <p>O Java é uma linguagem de programação orientada a objetos, popular para o desenvolvimento de aplicações robustas e seguras. Aqui abordamos um conceito fundamental.</p>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Serializable</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>A interface <strong><code>Serializable</code></strong> é uma interface de marcação em Java que não possui métodos. Ao implementar essa interface, você indica que um objeto pode ser transformado em uma sequência de bytes (serializado). Isso é útil para:</p>
                    <ul>
                        <li>Persistir o objeto em um arquivo.</li>
                        <li>Transmitir o objeto pela rede.</li>
                        <li>Armazenar o objeto em cache.</li>
                    </ul>
                    <p>O Spring Boot utiliza a serialização em diversos contextos, como em DTOs, entidades e sessões HTTP.</p>
                    <h4>Exemplo</h4>
                    <pre><code>import java.io.Serializable;

public class User implements Serializable {
    private String name;
    private int age;

    // Construtores, getters e setters
}</code></pre>
                </div>
            </div>
        </section>

        <section id="spring-boot">
            <h1>Spring Boot</h1>
            <p>O Spring Boot é um framework que simplifica a criação de aplicações Spring, permitindo o rápido desenvolvimento de APIs e microserviços.</p>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Principais Anotações</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>No Spring Boot, anotações são usadas para configurar e descrever o comportamento dos componentes da sua aplicação. Algumas das mais importantes são:</p>
                    <ul>
                        <li><strong><code>@SpringBootApplication</code></strong>: Marca a classe principal da aplicação, combinando as funcionalidades de <code>@Configuration</code>, <code>@EnableAutoConfiguration</code> e <code>@ComponentScan</code>.</li>
                        <li><strong><code>@Controller</code></strong> / <strong><code>@RestController</code></strong>: Indica que uma classe é um "Controller" na arquitetura MVC. <code>@RestController</code> é uma versão especializada para APIs REST, pois já inclui <code>@ResponseBody</code>.</li>
                        <li><strong><code>@Service</code></strong>: Marca uma classe como um componente de serviço, que contém a lógica de negócio.</li>
                        <li><strong><code>@Repository</code></strong>: Indica que uma classe é um componente de acesso a dados.</li>
                        <li><strong><code>@Component</code></strong>: Anotação genérica para qualquer componente gerenciado pelo Spring.</li>
                        <li><strong><code>@Autowired</code></strong>: Realiza a injeção automática de dependências. Embora popular, a injeção via construtor é a mais recomendada.</li>
                        <li><strong><code>@RequestMapping</code></strong>: Mapeia requisições HTTP para métodos específicos do controller.</li>
                        <li><strong><code>@GetMapping</code></strong>, <strong><code>@PostMapping</code></strong>, <strong><code>@PutMapping</code></strong>, <strong><code>@DeleteMapping</code></strong>: Anotações mais específicas que mapeiam os verbos HTTP correspondentes.</li>
                    </ul>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Injeção de Dependências</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p><strong>Injeção de Dependência (DI)</strong> é um princípio de design de software em que uma classe não cria suas próprias dependências, mas as recebe de uma fonte externa (o framework, no caso do Spring).</p>
                    <h4>Formas de Injeção no Spring</h4>
                    <ul>
                        <li><strong>Injeção via Construtor (Recomendada)</strong>: As dependências são passadas como argumentos no construtor da classe.
                            <pre><code>@Service
public class MatriculaService {
    private final AlunoRepository alunoRepository;

    public MatriculaService(AlunoRepository alunoRepository) {
        this.alunoRepository = alunoRepository;
    }
}</code></pre>
                            <p><strong>Vantagens:</strong> imutabilidade, facilita testes, garantia de que a dependência não é nula.</p>
                        </li>
                        <li><strong>Injeção via Setter</strong>: As dependências são injetadas através de métodos setters. Usada para dependências opcionais.
                            <pre><code>@Service
public class MatriculaService {
    private AlunoRepository alunoRepository;
    
    @Autowired
    public void setAlunoRepository(AlunoRepository alunoRepository) {
        this.alunoRepository = alunoRepository;
    }
}</code></pre>
                        </li>
                        <li><strong>Injeção via Campo (Menos Recomendada)</strong>: A dependência é injetada diretamente no campo da classe.
                            <pre><code>@Service
public class MatriculaService {
    @Autowired
    private AlunoRepository alunoRepository;
}</code></pre>
                            <p><strong>Problemas:</strong> Dificulta testes, oculta dependências reais e viola o princípio de imutabilidade.</p>
                        </li>
                    </ul>
                    <table>
                        <thead>
                            <tr>
                                <th>Tipo</th>
                                <th>Uso Recomendado?</th>
                                <th>Observações</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Construtor</td>
                                <td>Sim</td>
                                <td>Facilita testes, imutável</td>
                            </tr>
                            <tr>
                                <td>Setter</td>
                                <td>Opcional</td>
                                <td>Para dependências opcionais</td>
                            </tr>
                            <tr>
                                <td>Campo (@Autowired)</td>
                                <td>Evitar</td>
                                <td>Dificulta testes, não imutável</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>DTO (Data Transfer Object)</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>Um <strong>DTO</strong> é um objeto que transporta dados entre as camadas da sua aplicação, sem expor a entidade do banco de dados. Ele serve como uma barreira de segurança e encapsulamento.</p>
                    <h4>Vantagens</h4>
                    <ul>
                        <li><strong>Segurança:</strong> Evita expor toda a estrutura da entidade.</li>
                        <li><strong>Flexibilidade:</strong> Permite alterar a entidade sem quebrar a API.</li>
                        <li><strong>Validação:</strong> Facilita a validação de dados de entrada.</li>
                    </ul>
                    <p>O mapeamento entre DTO e Entity pode ser feito manualmente ou com bibliotecas como <strong>MapStruct</strong> para automatizar o processo.</p>
                    <h4>Exemplo de uso com MapStruct</h4>
                    <pre><code>// Interface do Mapper
@Mapper(componentModel = "spring")
public interface ProdutoMapper {
    ProdutoMapper INSTANCE = Mappers.getMapper(ProdutoMapper.class);

    Produto toEntity(ProdutoDTO dto);
    ProdutoDTO toDTO(Produto entity);
}

// Service refatorado
@Service
public class ProdutoService {
    @Autowired
    private ProdutoRepository produtoRepository;
    @Autowired
    private ProdutoMapper produtoMapper;

    public ProdutoDTO criarProduto(ProdutoDTO dto) {
        Produto produto = produtoMapper.toEntity(dto);
        produto = produtoRepository.save(produto);
        return produtoMapper.toDTO(produto);
    }
}</code></pre>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Controllers no Spring Boot</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>No padrão MVC, o Controller é o componente responsável por <strong>receber requisições HTTP</strong>, interagir com a lógica de negócio (Service) e retornar a resposta adequada ao cliente. Ele atua como um ponto de entrada para a aplicação.</p>
                    <h4>Anotações Fundamentais</h4>
                    <ul>
                        <li><code>@RestController</code>: Indica que a classe é um Controller REST.</li>
                        <li><code>@RequestMapping</code>: Define o caminho base para os endpoints.</li>
                        <li>Verbos HTTP (<code>@GetMapping</code>, <code>@PostMapping</code>, etc.): Mapeiam métodos para os verbos HTTP correspondentes.</li>
                        <li><code>@PathVariable</code>: Lê valores da URL (ex: <code>/recursos/{id}</code>).</li>
                        <li><code>@RequestParam</code>: Lê parâmetros de query (ex: <code>/recursos?page=1</code>).</li>
                        <li><code>@RequestBody</code>: Converte o corpo da requisição JSON para um objeto Java.</li>
                        <li><code>@ResponseStatus</code>: Define o status HTTP da resposta.</li>
                    </ul>
                    <h4>Boas Práticas</h4>
                    <ul>
                        <li>Manter os Controllers "finos", sem lógica de negócio.</li>
                        <li>Usar DTOs para requisição e resposta.</li>
                        <li>Retornar <code>ResponseEntity</code> para controlar status, headers e body da resposta.</li>
                        <li>Tratar exceções de forma centralizada com <code>@RestControllerAdvice</code>.</li>
                    </ul>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Validações em DTOs</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>Para validar os campos de um DTO no Spring Boot, você precisa usar a biblioteca de validação. A dependência necessária no <code>pom.xml</code> é <code>spring-boot-starter-validation</code>.</p>
                    <h4>Anotações de Validação Comuns</h4>
                    <ul>
                        <li><code>@NotNull</code>: O campo não pode ser nulo.</li>
                        <li><code>@NotBlank</code>: Para Strings, não pode ser nulo nem vazio.</li>
                        <li><code>@Size(min, max)</code>: Tamanho mínimo e máximo de uma string ou coleção.</li>
                        <li><code>@Email</code>: Valida se o formato é de e-mail.</li>
                        <li><code>@Min</code> / <code>@Max</code>: Define um valor numérico mínimo ou máximo.</li>
                    </ul>
                    <h4>Exemplo</h4>
                    <p>Aplique as anotações diretamente no DTO e use <code>@Valid</code> no parâmetro do Controller:</p>
                    <pre><code>public class UserDTO {
    @NotBlank(message = "Name is mandatory")
    private String name;

    @Email(message = "Invalid email")
    private String email;
}

@RestController
public class UserController {
    @PostMapping("/users")
    public ResponseEntity&lt;UserDTO&gt; createUser(@Valid @RequestBody UserDTO userDto) {
        // Lógica de criação
        return ResponseEntity.ok(userDto);
    }
}</code></pre>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Tratamento Global de Exceções</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>O <strong>tratamento global de exceções</strong> em uma API Spring Boot usando <code>@RestControllerAdvice</code> permite centralizar a manipulação de erros, garantindo respostas consistentes com o status HTTP correto para o cliente.</p>
                    <h4>Passos para Implementação</h4>
                    <ol>
                        <li><strong>Crie uma classe de resposta de erro:</strong> um objeto que irá padronizar a resposta de erro.
                            <pre><code>public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    // construtor, getters e setters
}</code></pre>
                        </li>
                        <li><strong>Defina exceções personalizadas:</strong> Crie classes de exceção para cada tipo de erro de negócio.
                            <pre><code>public class NotFoundException extends RuntimeException {
    public NotFoundException(String message) {
        super(message);
    }
}
// outras classes como BadRequestException, ConflictException, etc.</code></pre>
                        </li>
                        <li><strong>Crie o <code>GlobalExceptionHandler</code>:</strong> Anotado com <code>@RestControllerAdvice</code>, esta classe irá capturar as exceções lançadas na aplicação.
                            <pre><code>@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleNotFound(NotFoundException ex, HttpServletRequest request) {
        // Lógica para construir e retornar a resposta 404
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(buildResponse(...));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleGeneric(Exception ex, HttpServletRequest request) {
        // Lógica para capturar e tratar exceções genéricas (500)
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(buildResponse(...));
    }
}</code></pre>
                        </li>
                        <li><strong>Integre com o Service e Controller:</strong> Lance as exceções personalizadas na camada de serviço, e o <code>@RestControllerAdvice</code> se encarregará de tratá-las automaticamente.
                            <pre><code>@Service
public class CategoryService {
    // ...
    public Category getCategory(Long id) {
        return repository.findById(id)
                        .orElseThrow(() -> new NotFoundException("Category not found."));
    }
}</code></pre>
                        </li>
                    </ol>
                </div>
            </div>
        </section>

        <section id="spring-data-jpa">
            <h1>Spring Data JPA</h1>
            <p>O Spring Data JPA é uma abstração do JPA que simplifica a implementação de repositórios, permitindo a criação de classes de acesso a dados com menos código.</p>
            <div class="collapsible">
                <div class="collapsible-header">
                    <span>Associações</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>Em JPA, uma associação é uma relação entre entidades que reflete as relações entre as tabelas do banco de dados.</p>
                    <ul>
                        <li><strong><code>@OneToOne</code></strong>: Relação de um para um (1:1).</li>
                        <li><strong><code>@OneToMany</code></strong>: Relação de um para muitos (1:N).</li>
                        <li><strong><code>@ManyToOne</code></strong>: Relação de muitos para um (N:1).</li>
                        <li><strong><code>@ManyToMany</code></strong>: Relação de muitos para muitos (N:N).</li>
                    </ul>
                    <h4>Dono da Relação (<code>mappedBy</code>)</h4>
                    <p>Em associações bidirecionais, apenas um lado é o "dono" da relação. O lado dono é aquele que contém a chave estrangeira (FK) no banco de dados e é anotado com <code>@JoinColumn</code>. O outro lado é o inverso e usa <code>mappedBy</code> para espelhar a relação, sem gerenciar a FK.</p>
                    <pre><code>// DONO
@Entity
public class Pedido {
    @ManyToOne
    @JoinColumn(name = "cliente_id")
    private Cliente cliente;
}

// INVERSO
@Entity
public class Cliente {
    @OneToMany(mappedBy = "cliente")
    private List&lt;Pedido&gt; pedidos;
}</code></pre>
                    <h4>Fetch Type (Carregamento)</h4>
                    <ul>
                        <li><strong>EAGER:</strong> Carrega a associação junto com a entidade principal. Padrão para <code>@OneToOne</code> e <code>@ManyToOne</code>.</li>
                        <li><strong>LAZY:</strong> Carrega a associação apenas quando é acessada. Padrão para <code>@OneToMany</code> e <code>@ManyToMany</code> (recomendado para evitar problemas de performance).</li>
                    </ul>
                    <h4>Cascade (Propagação de operações)</h4>
                    <p>Define se operações como salvar (<code>PERSIST</code>) ou deletar (<code>REMOVE</code>) na entidade principal também se propagam para as entidades associadas. <code>CascadeType.ALL</code> propaga todas as operações.</p>
                </div>
            </div>
        </section>

        <section id="camadas">
            <h1>Estrutura de Camadas</h1>
            <p>Uma arquitetura de camadas é uma prática de design de software que separa a aplicação em grupos lógicos de responsabilidades. No contexto de uma API REST com Spring Boot, a estrutura mais comum é baseada em "features" ou "domínios", como "Category" no seu exemplo.</p>

            <div class="collapsible">
                <div class="collapsible-header">
                    <span>O que fazer em cada camada?</span>
                    <span>▼</span>
                </div>
                <div class="collapsible-content">
                    <p>A seguir, uma explicação do papel de cada camada na sua estrutura de projeto:</p>
                    <br>
                    <h3><code>models</code></h3>
                    <p>O pacote <code>models</code>, ou <code>domain</code>, é o coração da sua aplicação, onde a lógica de negócio e as estruturas de dados são definidas. Geralmente, ele é subdividido em:</p>
                    <h4><code>entities</code></h4>
                    <p>As <strong>Entities</strong> são classes que representam as tabelas do seu banco de dados. Elas são a representação Java de um registro, com campos mapeados para colunas usando anotações JPA como <code>@Entity</code>, <code>@Table</code>, <code>@Id</code>, e <code>@Column</code>. Elas não devem conter lógica de negócio complexa nem ser expostas diretamente para o cliente, para evitar problemas de segurança e acoplamento.</p>
                    <h4><code>repositories</code></h4>
                    <p>Os <strong>Repositories</strong> são interfaces que fornecem métodos para acessar e manipular os dados no banco de dados. O Spring Data JPA cria a implementação automaticamente para você, permitindo que você defina métodos de consulta como <code>findByNomeIgnoreCase</code> sem a necessidade de escrever código SQL. Eles se comunicam com a camada de entidade para persistir ou buscar dados.</p>
                    <h4><code>dto</code></h4>
                    <p>Os <strong>Data Transfer Objects (DTOs)</strong> são classes que representam a estrutura de dados que será enviada ou recebida pela API. Como DTOs não são mapeados para o banco de dados, você pode personalizá-los para incluir apenas os campos necessários para uma determinada operação (ex: <code>CategoryCreateDTO</code>, <code>CategoryResponseDTO</code>). Eles servem como uma barreira entre o cliente e a camada de entidade, protegendo o modelo de domínio.</p>
                    <h4><code>mappers</code></h4>
                    <p>Mappers são interfaces ou classes responsáveis por converter dados entre diferentes tipos, como de um DTO para uma Entity e vice-versa. Eles ajudam a manter a separação entre as camadas, evitando que a lógica de conversão se misture na camada de serviço. Bibliotecas como <strong>MapStruct</strong> automatizam esse processo de mapeamento, reduzindo o código boilerplate.</p>
                </div>
            </div>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('main-content');
            const toggleBtn = document.getElementById('toggle-sidebar');
            const sections = document.querySelectorAll('.content section');
            const buttons = document.querySelectorAll('.sidebar ul li button');
            const collapsibles = document.querySelectorAll('.collapsible');

            function showContent(id) {
                sections.forEach(section => {
                    section.classList.remove('active');
                });
                buttons.forEach(button => {
                    button.classList.remove('active');
                });
                document.getElementById(id).classList.add('active');
                document.querySelector(`button[onclick="showContent('${id}')"]`).classList.add('active');
            }

            window.showContent = showContent;

            // Inicia com o primeiro tópico ativo
            if (buttons.length > 0) {
                showContent(buttons[0].getAttribute('onclick').match(/'(.*?)'/)[1]);
            }

            collapsibles.forEach(collapsible => {
                const header = collapsible.querySelector('.collapsible-header');
                const content = collapsible.querySelector('.collapsible-content');
                const icon = header.querySelector('span:last-child');

                header.addEventListener('click', () => {
                    const isOpen = content.classList.contains('open');
                    
                    // Fecha todos os outros
                    document.querySelectorAll('.collapsible-content.open').forEach(c => {
                        if (c !== content) {
                            c.classList.remove('open');
                            c.previousElementSibling.querySelector('span:last-child').textContent = '▼';
                        }
                    });

                    if (isOpen) {
                        content.classList.remove('open');
                        icon.textContent = '▼';
                    } else {
                        content.classList.add('open');
                        icon.textContent = '▲';
                    }
                });
            });

            toggleBtn.addEventListener('click', () => {
                sidebar.classList.toggle('visible');
                mainContent.classList.toggle('sidebar-visible');
            });
        });
    </script>
</body>
</html>